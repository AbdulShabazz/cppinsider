test case:
  std::vector<int> primes { 2,3,5,7,11 };

test case:
__stdlog__({ "" }); 

test case:
std::vector<std::string> TraceCallStackStdStrVec{ "EuclidProver" };
		std::cout << " >> " << TraceCallStackStdStrVec[i];

test case:
input:the "cat"" jumped" over the lazy dog.
output:the <span class="string">"cat"</span> <span class="string">" jumped"</span> over the lazy dog.

input:the 'cat'' jumped' over the lazy dog.
output:the <span class="string">'cat'</span> <span class="string">' jumped'</span> over the lazy dog.

input:the "cat'" jumped' over the lazy dog.
output:the <span class="string">"cat'"</span> jumped<span class="string">' over the lazy dog.</span>

input:the 'cat"' jumped" over the lazy dog.
output:the <span class="string">'cat"'</span> jumped<span class="string">" over the lazy dog.</span>

test case:
std::vector<typename ar> primes {2,3,5,7,11}; 

test case:
std::vector<typename ar > primes { 2,3,5,7,11 };

test case:
std::vector<int> primes { 2,3,5,7,11 }; /* This is a comment */ // This is a line comment

test case:
std::vector< int > primes { 2,3,5,7,11 };

test case:
int keyvalue = 123455; int /*Paste your code /* +// comments here*/  This // is a line comment

test case:
<span class="keyword">int</span> keyvalue = <span class="digit">123455</span>; <span class="keyword">int</span><span class="comment">/*Paste your code + comments here*/</span><br><span class="line_comment">// This is a line comment</span>

const cpp_highlight = [
    "alignof", "and", "and_eq", "bitand", "bitor", "break", "case", "catch",
    "compl", "const_cast", "continue", "default", "delete", "do", "dynamic_cast",
    "else", "false", "for", "goto", "if", "namespace", "new", "not", "not_eq",
    "nullptr", "operator", "or", "or_eq", "reinterpret_cast", "return", "sizeof",
    "static_assert", "static_cast", "switch", "this", "throw", "true", "try",
    "typedef", "typeid", "using", "while", "xor", "xor_eq", "NULL", "alignas",
    "asm", "auto", "bool", "char", "char16_t", "char32_t", "class", "clock_t",
    "concept", "const", "consteval", "constexpr", "constinit", "decltype", "double",
    "enum", "explicit", "export", "extern", "final", "float", "friend", "inline",
    "int", "int8_t", "int16_t", "int32_t", "int64_t", "int_fast8_t", "int_fast16_t",
    "int_fast32_t", "int_fast64_t", "intmax_t", "intptr_t", "long", "mutable",
    "noexcept", "override", "private", "protected", "ptrdiff_t", "public", "register",
    "requires", "short", "signed", "size_t", "ssize_t", "static", "struct", "template",
    "thread_local", "time_t", "typename", "uint8_t", "uint16_t", "uint32_t", "uint64_t",
    "uint_fast8_t", "uint_fast16_t", "uint_fast32_t", "uint_fast64_t", "uintmax_t",
    "uintptr_t", "union", "unsigned", "virtual", "void", "volatile", "wchar_t"
];

const js_highlight = [
    "abstract", "async", "await", "boolean", "break", "byte", "case", "catch", "char", 
    "class", "const", "continue", "debugger", "default", "delete", "do", "double", "else", 
    "enum", "export", "extends", "final", "finally", "float", "for", "function", "goto", 
    "if", "implements", "import", "in", "instanceof", "int", "interface", "let", "long", 
    "native", "new", "null", "of", "package", "private", "protected", "public", "return", 
    "short", "static", "super", "switch", "synchronized", "this", "throw", "throws", 
    "transient", "try", "typeof", "var", "void", "volatile", "while", "with", "true", 
    "false", "prototype", "yield"
]

const js_type_highlight = [
    "Array", "Date", "eval", "hasOwnProperty", "Infinity", "isFinite", "isNaN", "isPrototypeOf", 
    "Math", "NaN", "Number", "Object", "prototype", "String", "toString", "undefined", "valueOf"
]

const js_window_highlight = [
    "alert", "all", "anchor", "anchors", "area", "assign", "blur", "button", "checkbox", "clearInterval", 
    "clearTimeout", "clientInformation", "close", "closed", "confirm", "constructor", "crypto", "decodeURI", 
    "decodeURIComponent", "defaultStatus", "document", "element", "elements", "embed", "embeds", "encodeURI", 
    "encodeURIComponent", "escape", "event", "fileUpload", "focus", "form", "forms", "frame", "innerHeight", 
    "innerWidth", "layer", "layers", "link", "location", "mimeTypes", "navigate", "navigator", "frames", 
    "frameRate", "hidden", "history", "image", "images", "offscreenBuffering", "onblur", "onclick", "onerror", 
    "onfocus", "onkeydown", "onkeypress", "onkeyup", "onmouseover", "onload", "onmouseup", "onmousedown", "onsubmit", 
    "open", "opener", "option", "outerHeight", "outerWidth", "packages", "pageXOffset", "pageYOffset", "parent", "parseFloat", 
    "parseInt", "password", "pkcs11", "plugin", "prompt", "propertyIsEnum", "radio", "reset", "screenX", "screenY", 
    "scroll", "secure", "select", "self", "setInterval", "setTimeout", "status", "submit", "taint", "text", "textarea", 
    "top", "unescape", "untaint", "window"
]

const py_highlight = [
    "and", "as", "assert", "async", "await", "break", "class", "continue", "def", "del", "elif", 
    "else", "except", "finally", "for", "from", "global", "if", "import", "in", "is", "lambda", 
    "nonlocal", "not", "or", "pass", "raise", "return", "try", "while", "with", "yield"
]

const py_utils_highlight = [
    "ArithmeticError", "AssertionError", "AttributeError", "BaseException", "BlockingIOError", 
    "BrokenPipeError", "BufferError", "BytesWarning", "ChildProcessError", "ConnectionAbortedError", 
    "ConnectionError", "ConnectionRefusedError", "ConnectionResetError", "DeprecationWarning", 
    "EOFError", "Ellipsis", "EnvironmentError", "Exception", "False", "FileExistsError", 
    "FileNotFoundError", "FloatingPointError", "FutureWarning", "GeneratorExit", "IOError", 
    "ImportError", "ImportWarning", "IndentationError", "IndexError", "InterruptedError", 
    "IsADirectoryError", "KeyError", "KeyboardInterrupt", "LookupError", "MemoryError", 
    "ModuleNotFoundError", "NameError", "None", "NotADirectoryError", "NotImplemented", 
    "NotImplementedError", "OSError", "OverflowError", "PendingDeprecationWarning", 
    "PermissionError", "ProcessLookupError", "RecursionError", "ReferenceError", "ResourceWarning", 
    "RuntimeError", "RuntimeWarning", "StopAsyncIteration", "StopIteration", "SyntaxError", 
    "SyntaxWarning", "SystemError", "SystemExit", "TabError", "TimeoutError", "True", "TypeError", 
    "UnboundLocalError", "UnicodeDecodeError", "UnicodeEncodeError", "UnicodeError", "UnicodeTranslateError", 
    "UnicodeWarning", "UserWarning", "ValueError", "Warning", "WindowsError", "ZeroDivisionError", 
    "abs", "all", "any", "ascii", "bin", "bool", "breakpoint", "bytearray", "bytes", "callable", "chr", 
    "classmethod", "compile", "complex", "copyright", "credits", "delattr", "dict", "dir", "divmod", 
    "enumerate", "eval", "exec", "exit", "filter", "float", "format", "frozenset", "getattr", "globals", 
    "hasattr", "hash", "help", "hex", "id", "input", "int", "isinstance", "issubclass", "iter", "len", 
    "license", "list", "locals", "map", "max", "memoryview", "min", "next", "object", "oct", "open", 
    "ord", "pow", "print", "property", "quit", "range", "repr", "reversed", "round", "set", "setattr", 
    "slice", "sorted", "staticmethod", "str", "sum", "super", "tuple", "type", "vars", "zip"
]

const keywords = [
    "alignof", "and", "and_eq", "bitand", "bitor", "break", "case", "catch",
    "compl", "const_cast", "continue", "default", "delete", "do", "dynamic_cast",
    "else", "false", "for", "goto", "if", "namespace", "new", "not", "not_eq",
    "nullptr", "operator", "or", "or_eq", "reinterpret_cast", "return", "sizeof",
    "static_assert", "static_cast", "switch", "this", "throw", "true", "try",
    "typedef", "typeid", "using", "while", "xor", "xor_eq", "NULL", "alignas",
    "asm", "auto", "bool", "char", "char16_t", "char32_t", "class", "clock_t",
    "concept", "const", "consteval", "constexpr", "constinit", "decltype", "double",
    "enum", "explicit", "export", "extern", "final", "float", "friend", "inline",
    "int", "int8_t", "int16_t", "int32_t", "int64_t", "int_fast8_t", "int_fast16_t",
    "int_fast32_t", "int_fast64_t", "intmax_t", "intptr_t", "long", "mutable",
    "noexcept", "override", "private", "protected", "ptrdiff_t", "public", "register",
    "requires", "short", "signed", "size_t", "ssize_t", "static", "struct", "template",
    "thread_local", "time_t", "typename", "uint8_t", "uint16_t", "uint32_t", "uint64_t",
    "uint_fast8_t", "uint_fast16_t", "uint_fast32_t", "uint_fast64_t", "uintmax_t",
    "uintptr_t", "union", "unsigned", "virtual", "void", "volatile", "wchar_t"
];

const cpp_highlight = [

    // cpp
    "alignof", "and", "and_eq", "bitand", "bitor", "break", "case", "catch", "class", 
    "compl", "const_cast", "continue", "default", "delete", "do", "dynamic_cast",
    "else", "false", "for", "goto", "if", "namespace", "new", "not", "not_eq",
    "nullptr", "operator", "or", "or_eq", "reinterpret_cast", "return", "sizeof",
    "static_assert", "static_cast", "switch", "this", "throw", "true", "try",
    "typedef", "typeid", "using", "while", "xor", "xor_eq", "NULL", "alignas",
    "asm", "auto", "bool", "char", "char16_t", "char32_t", "class", "clock_t",
    "concept", "const", "consteval", "constexpr", "constinit", "decltype", "double",
    "enum", "explicit", "export", "extern", "final", "float", "friend", "inline",
    "int", "int8_t", "int16_t", "int32_t", "int64_t", "int_fast8_t", "int_fast16_t",
    "int_fast32_t", "int_fast64_t", "intmax_t", "intptr_t", "long", "mutable",
    "noexcept", "override", "private", "protected", "ptrdiff_t", "public", "register",
    "requires", "short", "signed", "size_t", "ssize_t", "static", "struct", "template",
    "thread_local", "time_t", "typename", "uint8_t", "uint16_t", "uint32_t", "uint64_t",
    "uint_fast8_t", "uint_fast16_t", "uint_fast32_t", "uint_fast64_t", "uintmax_t", "uinion",
    "uintptr_t", "union", "unsigned", "virtual", "void", "volatile", "wchar_t",

    // js
    "abstract", "async", "await", "boolean", "break", "byte", "case", "catch", "char", 
    "class", "const", "continue", "debugger", "default", "delete", "do", "double", "else", 
    "enum", "export", "extends", "final", "finally", "float", "for", "function", "goto", 
    "if", "implements", "import", "in", "instanceof", "int", "interface", "let", "long", 
    "native", "new", "null", "of", "package", "private", "protected", "public", "return", 
    "short", "static", "super", "switch", "synchronized", "this", "throw", "throws", 
    "transient", "try", "typeof", "var", "void", "volatile", "while", "with", "true", 
    "false", "prototype", "yield",

    //js dom
    "alert", "all", "anchor", "anchors", "area", "assign", "blur", "button", "checkbox", "clearInterval", 
    "clearTimeout", "clientInformation", "close", "closed", "confirm", "constructor", "crypto", "decodeURI", 
    "decodeURIComponent", "defaultStatus", "document", "element", "elements", "embed", "embeds", "encodeURI", 
    "encodeURIComponent", "escape", "event", "fileUpload", "focus", "form", "forms", "frame", "innerHeight", 
    "innerWidth", "layer", "layers", "link", "location", "mimeTypes", "navigate", "navigator", "frames", 
    "frameRate", "hidden", "history", "image", "images", "offscreenBuffering", "onblur", "onclick", "onerror", 
    "onfocus", "onkeydown", "onkeypress", "onkeyup", "onmouseover", "onload", "onmouseup", "onmousedown", "onsubmit", 
    "open", "opener", "option", "outerHeight", "outerWidth", "packages", "pageXOffset", "pageYOffset", "parent", "parseFloat", 
    "parseInt", "password", "pkcs11", "plugin", "prompt", "propertyIsEnum", "radio", "reset", "screenX", "screenY", 
    "scroll", "secure", "select", "self", "setInterval", "setTimeout", "status", "submit", "taint", "text", "textarea", 
    "top", "unescape", "untaint", "window",

    // py
    "and", "as", "assert", "async", "await", "break", "class", "continue", "def", "del", "elif", 
    "else", "except", "finally", "for", "from", "global", "if", "import", "in", "is", "lambda", 
    "nonlocal", "not", "or", "pass", "raise", "return", "try", "while", "with", "yield"
];

const utils_highlight = [

    // js
    "Array", "Date", "eval", "hasOwnProperty", "Infinity", "isFinite", "isNaN", "isPrototypeOf", 
    "Math", "NaN", "Number", "Object", "prototype", "String", "toString", "undefined", "valueOf",

    // py
    "ArithmeticError", "AssertionError", "AttributeError", "BaseException", "BlockingIOError", 
    "BrokenPipeError", "BufferError", "BytesWarning", "ChildProcessError", "ConnectionAbortedError", 
    "ConnectionError", "ConnectionRefusedError", "ConnectionResetError", "DeprecationWarning", 
    "EOFError", "Ellipsis", "EnvironmentError", "Exception", "False", "FileExistsError", 
    "FileNotFoundError", "FloatingPointError", "FutureWarning", "GeneratorExit", "IOError", 
    "ImportError", "ImportWarning", "IndentationError", "IndexError", "InterruptedError", 
    "IsADirectoryError", "KeyError", "KeyboardInterrupt", "LookupError", "MemoryError", 
    "ModuleNotFoundError", "NameError", "None", "NotADirectoryError", "NotImplemented", 
    "NotImplementedError", "OSError", "OverflowError", "PendingDeprecationWarning", 
    "PermissionError", "ProcessLookupError", "RecursionError", "ReferenceError", "ResourceWarning", 
    "RuntimeError", "RuntimeWarning", "StopAsyncIteration", "StopIteration", "SyntaxError", 
    "SyntaxWarning", "SystemError", "SystemExit", "TabError", "TimeoutError", "True", "TypeError", 
    "UnboundLocalError", "UnicodeDecodeError", "UnicodeEncodeError", "UnicodeError", "UnicodeTranslateError", 
    "UnicodeWarning", "UserWarning", "ValueError", "Warning", "WindowsError", "ZeroDivisionError", 
    "abs", "all", "any", "ascii", "bin", "bool", "breakpoint", "bytearray", "bytes", "callable", "chr", 
    "classmethod", "compile", "complex", "copyright", "credits", "delattr", "dict", "dir", "divmod", 
    "enumerate", "eval", "exec", "exit", "filter", "float", "format", "frozenset", "getattr", "globals", 
    "hasattr", "hash", "help", "hex", "id", "input", "int", "isinstance", "issubclass", "iter", "len", 
    "license", "list", "locals", "map", "max", "memoryview", "min", "next", "object", "oct", "open", 
    "ord", "pow", "print", "property", "quit", "range", "repr", "reversed", "round", "set", "setattr", 
    "slice", "sorted", "staticmethod", "str", "sum", "super", "tuple", "type", "vars", "zip"

];

const cpp_highlight = /\b(alignof|and|and_eq|bitand|bitor|break|case|catch|class|compl|const_cast|continue|default|delete|do|dynamic_cast|else|false|for|goto|if|namespace|new|not|not_eq|nullptr|operator|or|or_eq|reinterpret_cast|return|sizeof|static_assert|static_cast|switch|this|throw|true|try|typedef|typeid|using|while|xor|xor_eq|NULL|alignas|asm|auto|bool|char|char16_t|char32_t|class|clock_t|concept|const|consteval|constexpr|constinit|decltype|double|enum|explicit|export|extern|final|float|friend|inline|int|int8_t|int16_t|int32_t|int64_t|int_fast8_t|int_fast16_t|int_fast32_t|int_fast64_t|intmax_t|intptr_t|long|mutable|noexcept|override|private|protected|ptrdiff_t|public|register|requires|short|signed|size_t|ssize_t|static|struct|template|thread_local|time_t|typename|uint8_t|uint16_t|uint32_t|uint64_t|uint_fast8_t|uint_fast16_t|uint_fast32_t|uint_fast64_t|uintmax_t|uinion|uintptr_t|union|unsigned|virtual|void|volatile|wchar_t|abstract|async|await|boolean|break|byte|case|catch|char|class|const|continue|debugger|default|delete|do|double|else|enum|export|extends|final|finally|float|for|function|goto|if|implements|import|in|instanceof|int|interface|let|long|native|new|null|of|package|private|protected|public|return|short|static|super|switch|synchronized|this|throw|throws|transient|try|typeof|var|void|volatile|while|with|true|false|prototype|yield|alert|all|anchor|anchors|area|assign|blur|button|checkbox|clearInterval|clearTimeout|clientInformation|close|closed|confirm|constructor|crypto|decodeURI|decodeURIComponent|defaultStatus|document|element|elements|embed|embeds|encodeURI|encodeURIComponent|escape|event|fileUpload|focus|form|forms|frame|innerHeight|innerWidth|layer|layers|link|location|mimeTypes|navigate|navigator|frames|frameRate|hidden|history|image|images|offscreenBuffering|onblur|onclick|onerror|onfocus|onkeydown|onkeypress|onkeyup|onmouseover|onload|onmouseup|onmousedown|onsubmit|open|opener|option|outerHeight|outerWidth|packages|pageXOffset|pageYOffset|parent|parseFloat|parseInt|password|pkcs11|plugin|prompt|propertyIsEnum|radio|reset|screenX|screenY|scroll|secure|select|self|setInterval|setTimeout|status|submit|taint|text|textarea|top|unescape|untaint|window|and|as|assert|async|await|break|class|continue|def|del|elif|else|except|finally|for|from|global|if|import|in|is|lambda|nonlocal|not|or|pass|raise|return|try|while|with|yield)\b/g;
const utils_highlight = /\b(Array|Date|eval|hasOwnProperty|Infinity|isFinite|isNaN|isPrototypeOf|Math|NaN|Number|Object|prototype|String|toString|undefined|valueOf|ArithmeticError|AssertionError|AttributeError|BaseException|BlockingIOError|BrokenPipeError|BufferError|BytesWarning|ChildProcessError|ConnectionAbortedError|ConnectionError|ConnectionRefusedError|ConnectionResetError|DeprecationWarning|EOFError|Ellipsis|EnvironmentError|Exception|False|FileExistsError|FileNotFoundError|FloatingPointError|FutureWarning|GeneratorExit|IOError|ImportError|ImportWarning|IndentationError|IndexError|InterruptedError|IsADirectoryError|KeyError|KeyboardInterrupt|LookupError|MemoryError|ModuleNotFoundError|NameError|None|NotADirectoryError|NotImplemented|NotImplementedError|OSError|OverflowError|PendingDeprecationWarning|PermissionError|ProcessLookupError|RecursionError|ReferenceError|ResourceWarning|RuntimeError|RuntimeWarning|StopAsyncIteration|StopIteration|SyntaxError|SyntaxWarning|SystemError|SystemExit|TabError|TimeoutError|True|TypeError|UnboundLocalError|UnicodeDecodeError|UnicodeEncodeError|UnicodeError|UnicodeTranslateError|UnicodeWarning|UserWarning|ValueError|Warning|WindowsError|ZeroDivisionError|abs|all|any|ascii|bin|bool|breakpoint|bytearray|bytes|callable|chr|classmethod|compile|complex|copyright|credits|delattr|dict|dir|divmod|enumerate|eval|exec|exit|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|isinstance|issubclass|iter|len|license|list|locals|map|max|memoryview|min|next|object|oct|open|ord|pow|print|property|quit|range|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|vars|zip)\b/g;

function highlightSyntax() {
    const codeSnippet = document.getElementById('code-snippet');

    // Save cursor position in plain text content
    //const savedCursorPos = getCaretCharacterOffsetWithin(codeSnippet);

    // Save scroll position
    const savedScrollTop = codeSnippet.scrollTop;

    let code = codeSnippet.innerText;
    const highlightedCode = code.split(' ').map((word) => {
        if (keywords.includes(word)) {
            return `<span class="keyword">${word}</span>`;
        }
        return word;
    }).join(' ');

    // Update content with highlighted syntax
    codeSnippet.innerHTML = highlightedCode;

    // Restore scroll position
    codeSnippet.scrollTop = savedScrollTop;

    // Restore cursor position in plain text content
    //setCaretPosition(codeSnippet, savedCursorPos);
}

function getCaretCharacterOffsetWithin(element) {
    var caretOffset = 0;
    var sel = window.getSelection();
    if (sel.rangeCount > 0) {
        var range = sel.getRangeAt(0);
        var preCaretRange = range.cloneRange();
        preCaretRange.selectNodeContents(element);
        preCaretRange.setEnd(range.endContainer, range.endOffset);
        caretOffset = preCaretRange.toString().length;
    }
    return caretOffset;
}

function setCaretPosition(el, pos) {
    var charCount = -1, node;

    var findPositionInText = function(parentNode) {
        var nodes = parentNode.childNodes;
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (charCount >= pos) {
                return;
            }
            if (node.nodeType === Node.TEXT_NODE) {
                charCount += node.length;
            } else {
                findPositionInText(node);
            }
            if (charCount >= pos) {
                var range = document.createRange();
                var sel = window.getSelection();
                range.setStart(node, pos - (charCount - node.length) - 1);
                range.collapse(true);
                sel.removeAllRanges();
                sel.addRange(range);
                return;
            }
        }
    };
    findPositionInText(el);
}

<div style="align-content: right;"></div>
<br><input id="cpp" class="submit" type="radio"> C++ </input>&nbsp;<input id="js" class="submit" type="radio"> JavaScript </input>&nbsp;<input id="py" class="submit" type="radio"> Python </input>


        
// handle new lines
if (word.includes("\n")) {
    word = word.replace(/\n/gm, "\n<br>");
}



let line_comment_flag = false; 
let block_comment_flag = false;

const code = codeSnippet.innerText;

const highlightedCode = code.split(/(\s)/).map((word, index, arr) => {
    // Add space after < or >
    if (word.includes("<")) {
        word = word.replace(/<\s*/g, "&lt; ");
    }

    if (word.includes(">")) {
        word = word.replace(/\s*>/g, " &gt;");
    }

    // Add space before { or }
    if (word.includes("}")) {
        word = word.replace(/\s*}/g, " }");
    }
    
    if (word.includes("{")) {
        word = word.replace(/{\s*/g, "{ ");
    }

    // handle block comments
    if (block_comment_flag) {
        if (word.includes("*/")) {
            block_comment_flag = false;
            return `${word}</span>`;
        }
        if (word.includes("\n")) {
            return `${word}</span><br>`;
        }
        return word;
    }

    // handle line comments
    if (line_comment_flag) {
        if (word.includes("\n")) {
            line_comment_flag = false;
            return `${word}</span><br>`;
        }
        return word;
    }

    // Check for starting of block comment
    if (word.includes("/*")) {
        block_comment_flag = true;
        return `<span class="comment">${word}`;
    }

    // Check for starting of line comment
    if (word.includes("//") || word.includes("#")) {
        line_comment_flag = true;
        return `<span class="line_comment">${word}`;
    }

    // Wrap numbers
    if (word.match(/^\d/)) {
        return `<span class="digit">${word}</span>`;
    }

    // Wrap scope resolution operators
    if (word.match(/::/)) {
        return word.replace(/::(\w+)/g, `::<span class="scope">$1</span>`);
    }

    // Wrap keywords
    if (cpp_highlight.includes(word)) {
        return `<span class="keyword">${word}</span>`;
    }

    // Wrap utility keywords
    if (utils_highlight.includes(word)) {
        return `<span class="utils">${word}</span>`;
    }

    // Replace newline characters with line breaks
    if (word.includes("\n")) {
        return `${word}<br>`;
    }

    return word;
}).join(' ');

// Wrap keywords
let ar;
if (ar = word.match(/(?<=\s)(\w+)(?=\s)/g)) {
    let matchFound = false;
    for(w of ar)
    {
        if (cpp_highlight.includes(w)) {
            matchFound = true;
            word = word.replace(w, `<span class="keyword">${w}</span>`);
        }
    }

    if(matchFound)
        return word;
}

The initial struct should represent an ideal real-world test case, to help me determine whether to focus on code size or code performance, which will suffice as a first test case .

<p class="note">
                Once completed, I will direct you to a URI for you to submit other test cases, if you desire, against the compiled binary, as well as view general details about the source code.
                If the test cases pass to your liking, and there are no further refactorings, there will be a referral on the page to a paypal address to complete payment. 
                Afterwards, a link will be provided to download the source code. At this point, refactoring requests will not be accepted.
                Copies of binaries can be provided along with the source code, upon request.</p>



        // Wrap keywords
        let ar;
        if (ar = word.match(/(?<=\s)(\w+),?(?=\s)/g)) {
            let matchFound = false;
            for(w of ar)
            {
                if (cpp_highlight.includes(w)) {
                    matchFound = true;
                    word = word.replace(w, `<span class="keyword">${w}</span>`);
                }
            }

            if(matchFound)
                return word;
        }



        // Add space after < or >
        if (word.includes("<")) {
            word = word.replace(/<\s*/g, "&lt; ");
        }

        if (word.includes(">")) {
            word = word.replace(/\s*>/g, " &gt;");
        }

        // Add space before { or }
        if (word.includes("}")) {
            word = word.replace(/\s*}/g, " }");
        }
        
        if (word.includes("{")) {
            word = word.replace(/{\s*/g, "{ ");
        }

        //
        
        let ar;
        if (ar = word.match(/&lt; ([\S]+) &gt;/g)) {
            for(w of ar)
            {
                word = word.replace(w, `<span class="keyword">${w}</span>`);
            }
            return word;
        } else if (cpp_highlight.includes(word)) {
            return `<span class="keyword">${word}</span>`;
        }

        let ar;
        if (ar = word.match(/(?<=\s)([\S]+)(?=\s)/g)) {
            for(w of ar)
            {
                word = word.replace(w, `<span class="keyword">${w}</span>`);
            }
            return word;
        }

        let ar;
        if (ar = word.match(/(\S+)/g)) {
            for(w of ar)
            {
                if (cpp_highlight.includes(w))
                    word = word.replaceAll(w, `<span class="keyword">${w}</span>`);
            }
            return word;
        }

        let ar;
        if (ar = word.match(/([\s,])+(\w+)([\s,])+/g)) {
            for(w of ar)
            {
                word = word.replace(w, `<span class="keyword">${w}</span>`);
            }
            return word;
        }

        let ar;
        if (ar = word.match(/&lt; (\S+) &gt;/g)) {
            for(w of ar)
            {
                for (let u of w.replace(/,/g, ' ').split(/\s/))
                    if (cpp_highlight.includes(u))
                        word = word.replaceAll(u, `<span class="keyword">${u}</span>`);
            }
            return word;
        }

//


function highlightSyntax() {
    const codeSnippet = document.getElementById('code-snippet');
    const codeDisplay = document.getElementById('code-display');

    if (codeSnippet.innerText === codeSnippet.lastInnerText)
        return;
    
    codeSnippet.lastInnerText = codeSnippet.innerText;
    //codeSnippet.lastInnerHtML = codeSnippet.innerHTML;

    // Save cursor position
    //const selection = document.getSelection();
    //const range = selection.getRangeAt(0);
    //const savedCursorPos = range.startOffset;
    //const savedCursorPos = getCaretCharacterOffsetWithin(codeSnippet);

    // Save scroll position
    const savedScrollTop = codeSnippet.scrollTop;
    const savedScrollHeight = codeSnippet.scrollHeight || 1;

    let line_comment_flag = false; 
    let block_comment_flag = false;

    const code = codeSnippet.innerText;

    const highlightedCode = code.split(/(\s)/).map((word, index, arr) => {

        // Add space after < or >
        if (word.includes("<")) {
            word = word.replace(/<\s*/g, "&lt; ");
        }

        if (word.includes(">")) {
            word = word.replace(/\s*>/g, " &gt;");
        }

        // Add space before { or }
        if (word.includes("}")) {
            word = word.replace(/\s*}/g, " }");
        }
        
        if (word.includes("{")) {
            word = word.replace(/{\s*/g, "{ ");
        }

        // Add space before [ or ]
        if (word.includes("]")) {
            word = word.replace(/\s*}/g, " ]");
        }
        
        if (word.includes("[")) {
            word = word.replace(/{\s*/g, "[ ");
        }

        // Add space before ( or )
        if (word.includes(")")) {
            word = word.replace(/\s*}/g, " )");
        }
        
        if (word.includes("(")) {
            word = word.replace(/{\s*/g, "( ");
        }

        // handle block comments
        if (block_comment_flag) {
            if (word.includes("*/")) {
                block_comment_flag = false;
                return `${word}</span>`;
            }
            if (word.includes("\n")) {
                return `${word}</span><br>`;
            }
            return word;
        }

        // handle line comments
        if (line_comment_flag) {
            if (word.includes("\n")) {
                line_comment_flag = false;
                return `${word}</span><br>`;
            }
            return word;
        }

        // Check for starting of block comment
        if (word.includes("/*")) {
            block_comment_flag = true;
            return `<span class="comment">${word}`;
        }

        // Check for starting of line comment
        if (word.includes("//") || word.includes("#")) {
            line_comment_flag = true;
            return `<span class="line_comment">${word}`;
        }

        // Wrap numbers
        let nr;
        if (nr = word.match(/(\d+)/g)) {
            for (let n of nr) {
                word = word.replace(n, `<span class="digit">${n}</span>`);
            }
            return word;
        }

        // Wrap scope resolution operators
        if (word.match(/::/)) {
            word = word.replace(/::(\w+)/g, `::<span class="scope">$1</span>`);
        }

        // Wrap keywords
        if (cpp_highlight.includes(word)) {
            return `<span class="keyword">${word}</span>`;
        }

        let ar;
        if (ar = word.match(/&lt; (.+)/g)) {
            for(w of ar)
            {
                for (let u of w.replace(/,/g, ' ').split(/\s/))
                    if (cpp_highlight.includes(u))
                        word = word.replaceAll(u, `<span class="keyword">${u}</span>`);
            }
            return word;
        }

        // Wrap utility keywords
        if (utils_highlight.includes(word)) {
            return `<span class="utils">${word}</span>`;
        }

        // Replace newline characters with line breaks
        if (word.includes("\n")) {
            return `${word}<br>`;
        }

        return word;
    }).join(' ');


    /*
    let idx = 0;
    let IDX = codeSnippet.innerHTML.length;
    const JDX = codeSnippet.innerHTML.length;
    let innerHtML = codeSnippet.innerHTML;

    // Find new character position (the first character that is different)
    for(let ch of highlightedCode.split(''))
    {
        if (idx <= IDX)
        {
            if(ch != codeSnippet.lastInnerHtML[idx])
            {
                break
            } else {
                ++idx;
            }
        } else {
            break;
        }
    }
    */
    //codeDisplay.innerHTML = highlightedCode;
    //codeDisplay.scrollTop = codeSnippet.scrollHeight;
	//codeSnippet.innerHTML = codeDisplay.innerHTML;
    codeDisplay.innerHTML = highlightedCode;//.replace(/\n/gm, "<br>");
    //codeSnippet.innerText = code;
    //codeSnippet.innerHTML = highlightedCode; 
    //IDX = highlightedCode.length;
    // Restore scroll position
    //codeSnippet.scrollTop = savedScrollTop * (codeSnippet.scrollHeight / savedScrollHeight);

    // Restore cursor position
    //setCursorAtPosition(codeSnippet, idx);
    //const restoredRange = document.createRange();
    //restoredRange.setStart(codeSnippet.firstChild, savedCursorPos);
    //restoredRange.setEnd(codeSnippet.firstChild, savedCursorPos);
    //restoredRange.collapse(true);
    //selection.removeAllRanges();
    //selection.addRange(restoredRange);

    //restoredRange.setStart(codeSnippet.lastChild, idx);
    //restoredRange.setEnd(codeSnippet.lastChild, selection.rangeCount);
    //restoredRange.collapse(selection.isCollapsed);
    //selection.removeAllRanges();
    //selection.addRange(restoredRange);
    
    //setCaretPosition(codeSnippet, savedCursorPos);
    
    //const range = document.createRange();
    //const selection = document.getSelection();
    //range.selectNodeContents(codeSnippet);

    // Collapses the Range to the end of the selected node
    //range.collapse(selection.isCollapsed);

    // Remove all ranges from the selection
    //selection.removeAllRanges();

    //range.setStart(codeSnippet.lasttChild, idx);
    //range.setEnd(codeSnippet.lasttChild, selection.rangeCount);

    // Add the Range to the selection
    //selection.addRange(range);

    //if (IDX != JDX)
    //codeSnippet.lastInnerHtML = codeSnippet.innerHTML;
}

function setCursorAtPosition(element, position) {
    const range = document.createRange();
    const selection = window.getSelection();
    
    let charCount = 0, node;
    const stack = [element];

    while (stack.length > 0) {
        const current = stack.shift();
        const nodes = current.childNodes;

        for (let i = 0; i < nodes.length; i++) {
            node = nodes[i];

            if (charCount >= position) {
                range.setStart(node, position - (charCount - node.length));
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);
                return;
            }

            if (node.nodeType === Node.TEXT_NODE) {
                charCount += node.length;
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                stack.push(node);
            }
        }
    }
}

function getCaretCharacterOffsetWithin(element) {
    var caretOffset = 0;
    var doc = element.ownerDocument || element.document;
    var win = doc.defaultView || doc.parentWindow;
    var sel;
    if (typeof win.getSelection !== "undefined") {
        sel = win.getSelection();
        if (sel.rangeCount > 0) {
            var range = win.getSelection().getRangeAt(0);
            var preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(element);
            preCaretRange.setEnd(range.endContainer, range.endOffset);
            caretOffset = preCaretRange.toString().length;
        }
    } else if ((sel = doc.selection) && sel.type !== "Control") {
        var textRange = sel.createRange();
        var preCaretTextRange = doc.body.createTextRange();
        preCaretTextRange.moveToElementText(element);
        preCaretTextRange.setEndPoint("EndToEnd", textRange);
        caretOffset = preCaretTextRange.text.length;
    }
    return caretOffset;
}

function setCaretPosition(el, pos) {
    // Loop through all child nodes
    var currentNode = null;
    var previousNode = null;
    var offset = 0;

    for (var i = 0; i < el.childNodes.length; i++) {
        previousNode = currentNode;
        currentNode = el.childNodes[i];
        // If it's a text node, add the length
        if (currentNode.nodeType === Node.TEXT_NODE) {
            offset += currentNode.length;
        }
        // if it's a keyword span, consider the extra characters
        else if (currentNode.nodeType === Node.ELEMENT_NODE && currentNode.tagName === 'SPAN') {
            offset += currentNode.innerText.length;
        }
        if (offset >= pos) break;
    }

    const range = document.createRange();
    const selection = window.getSelection();

    if (!currentNode) return;

    // Determine cursor position
    if (currentNode.nodeType === Node.TEXT_NODE) {
        range.setStart(previousNode || currentNode, pos - offset + (previousNode ? previousNode.length : 0));
    } else {
        range.setStart(currentNode, 0);
    }

    range.collapse(true);
    selection.removeAllRanges();
    selection.addRange(range);
}

//


const cpp_highlight = /\b(alignof|and|and_eq|bitand|bitor|break|case|catch|class|compl|const_cast|continue|default|delete|do|dynamic_cast|else|false|for|goto|if|namespace|new|not|not_eq|nullptr|operator|or|or_eq|reinterpret_cast|return|sizeof|static_assert|static_cast|switch|this|throw|true|try|typedef|typeid|using|while|xor|xor_eq|NULL|alignas|asm|auto|bool|char|char16_t|char32_t|class|clock_t|concept|const|consteval|constexpr|constinit|decltype|double|enum|explicit|export|extern|final|float|friend|inline|int|int8_t|int16_t|int32_t|int64_t|int_fast8_t|int_fast16_t|int_fast32_t|int_fast64_t|intmax_t|intptr_t|long|mutable|noexcept|override|private|protected|ptrdiff_t|public|register|requires|short|signed|size_t|ssize_t|static|struct|template|thread_local|time_t|typename|uint8_t|uint16_t|uint32_t|uint64_t|uint_fast8_t|uint_fast16_t|uint_fast32_t|uint_fast64_t|uintmax_t|uinion|uintptr_t|union|unsigned|virtual|void|volatile|wchar_t|abstract|async|await|boolean|break|byte|case|catch|char|class|const|continue|debugger|default|delete|do|double|else|enum|export|extends|final|finally|float|for|function|goto|if|implements|import|in|instanceof|int|interface|let|long|native|new|null|of|package|private|protected|public|return|short|static|super|switch|synchronized|this|throw|throws|transient|try|typeof|var|void|volatile|while|with|true|false|prototype|yield|alert|all|anchor|anchors|area|assign|blur|button|checkbox|clearInterval|clearTimeout|clientInformation|close|closed|confirm|constructor|crypto|decodeURI|decodeURIComponent|defaultStatus|document|element|elements|embed|embeds|encodeURI|encodeURIComponent|escape|event|fileUpload|focus|form|forms|frame|innerHeight|innerWidth|layer|layers|link|location|mimeTypes|navigate|navigator|frames|frameRate|hidden|history|image|images|offscreenBuffering|onblur|onclick|onerror|onfocus|onkeydown|onkeypress|onkeyup|onmouseover|onload|onmouseup|onmousedown|onsubmit|open|opener|option|outerHeight|outerWidth|packages|pageXOffset|pageYOffset|parent|parseFloat|parseInt|password|pkcs11|plugin|prompt|propertyIsEnum|radio|reset|screenX|screenY|scroll|secure|select|self|setInterval|setTimeout|status|submit|taint|text|textarea|top|unescape|untaint|window|and|as|assert|async|await|break|class|continue|def|del|elif|else|except|finally|for|from|global|if|import|in|is|lambda|nonlocal|not|or|pass|raise|return|try|while|with|yield)\b/g;
const utils_highlight = /\b(Array|Date|eval|hasOwnProperty|Infinity|isFinite|isNaN|isPrototypeOf|Math|NaN|Number|Object|prototype|String|toString|undefined|valueOf|ArithmeticError|AssertionError|AttributeError|BaseException|BlockingIOError|BrokenPipeError|BufferError|BytesWarning|ChildProcessError|ConnectionAbortedError|ConnectionError|ConnectionRefusedError|ConnectionResetError|DeprecationWarning|EOFError|Ellipsis|EnvironmentError|Exception|False|FileExistsError|FileNotFoundError|FloatingPointError|FutureWarning|GeneratorExit|IOError|ImportError|ImportWarning|IndentationError|IndexError|InterruptedError|IsADirectoryError|KeyError|KeyboardInterrupt|LookupError|MemoryError|ModuleNotFoundError|NameError|None|NotADirectoryError|NotImplemented|NotImplementedError|OSError|OverflowError|PendingDeprecationWarning|PermissionError|ProcessLookupError|RecursionError|ReferenceError|ResourceWarning|RuntimeError|RuntimeWarning|StopAsyncIteration|StopIteration|SyntaxError|SyntaxWarning|SystemError|SystemExit|TabError|TimeoutError|True|TypeError|UnboundLocalError|UnicodeDecodeError|UnicodeEncodeError|UnicodeError|UnicodeTranslateError|UnicodeWarning|UserWarning|ValueError|Warning|WindowsError|ZeroDivisionError|abs|all|any|ascii|bin|bool|breakpoint|bytearray|bytes|callable|chr|classmethod|compile|complex|copyright|credits|delattr|dict|dir|divmod|enumerate|eval|exec|exit|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|isinstance|issubclass|iter|len|license|list|locals|map|max|memoryview|min|next|object|oct|open|ord|pow|print|property|quit|range|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|vars|zip)\b/g;

function highlightSyntax() {
    const codeSnippet = document.getElementById('code-snippet');
    const codeDisplay = document.getElementById('code-display');

    if (codeSnippet.innerText === codeSnippet.lastInnerText)
        return;

    codeSnippet.lastInnerText = codeSnippet.innerText;
    function highlightCode(input) {
        // Define regex patterns
        const patterns = [
            { regex: /\b(\d+)\b/g, className: 'digit' },
            { regex: /(&lt;)/g, className: 'template_lt' },
            { regex: /(&gt;)/g, className: 'template_gt' },
            { regex: utils_highlight, className: 'keyword' },
            { regex: cpp_highlight, className: 'keyword' },
            { regex: /(\/\/[^\n]*)/g, className: 'line_comment' },
            { regex: /(\/\*[\s\S]*\*\/)/g, className: 'comment' }
        ];

        // Escape < and > for HTML
        input = input.replace(/</g, '&lt;').replace(/>/g, '&gt;');

        // Apply regex patterns
        for (const pattern of patterns) {
            input = input.replace(pattern.regex, `§span class="${pattern.className}"§§$1§/span§§`); // § is used as a temporary placeholder. It is unused in C++, Javascript, and Python.
        }

        return input.replace(/§§/g, '>').replace(/§/g, '<');
    }

    // Test cases
    const testCases = [
        'std::vector<typename ar> primes {22,3,5,7,11};',
        'std::vector<int> primes { 2,3,5,7,11 }; /* This is a comment */ // This is a line comment',
        'int keyvalue = 123455; int /*Paste your code /* +// comments here*/  This // is a line comment',
        'int keyvalue = 123455; int /*Paste your code + comments here*/ // This is a line comment',
    ];

    // Apply highlighter to test cases
    let outputHTML = '';
    let outputText = '';

    for (const testCase of testCases) {
        outputText += testCase + '\n';
        outputHTML += highlightCode(testCase) + '<br>';
    }

    // Output results
    codeSnippet.innerText = outputText;
    codeDisplay.innerHTML = outputHTML;
    //document.getElementById('output').innerHTML = outputHTML;

    codeSnippet.lastInnerText = codeSnippet.innerText;
}

//



    const highlightedCode = code.split(/(\s)/).map((word, index, arr) => {

        // Add space after < or >
        if (word.includes("<")) {
            word = word.replace(/<\s*/g, "&lt; ");
        }

        if (word.includes(">")) {
            word = word.replace(/\s*>/g, " &gt;");
        }

        // Add space before { or }
        if (word.includes("}")) {
            word = word.replace(/\s*}/g, " }");
        }
        
        if (word.includes("{")) {
            word = word.replace(/{\s*/g, "{ ");
        }

        // Add space before [ or ]
        if (word.includes("]")) {
            word = word.replace(/\s*}/g, " ]");
        }
        
        if (word.includes("[")) {
            word = word.replace(/{\s*/g, "[ ");
        }

        // Add space before ( or )
        if (word.includes(")")) {
            word = word.replace(/\s*}/g, " )");
        }
        
        if (word.includes("(")) {
            word = word.replace(/{\s*/g, "( ");
        }

        // handle block comments
        if (block_comment_flag) {
            if (word.includes("*/")) {
                block_comment_flag = false;
                return `${word}</span>`;
            }
            if (word.includes("\n")) {
                return `${word}</span><br>`;
            }
            return word;
        }

        // handle line comments
        if (line_comment_flag) {
            if (word.includes("\n")) {
                line_comment_flag = false;
                return `${word}</span><br>`;
            }
            return word;
        }

        // Check for starting of block comment
        if (word.includes("/*")) {
            block_comment_flag = true;
            return `<span class="comment">${word}`;
        }

        // Check for starting of line comment
        if (word.includes("//") || word.includes("#")) {
            line_comment_flag = true;
            return `<span class="line_comment">${word}`;
        }

        // Wrap numbers
        let nr;
        if (nr = word.match(/(\d+)/g)) {
            for (let n of nr) {
                word = word.replace(n, `<span class="digit">${n}</span>`);
            }
            return word;
        }

        // Wrap scope resolution operators
        if (word.match(/::/)) {
            word = word.replace(/::(\w+)/g, `::<span class="scope">$1</span>`);
        }

        // Wrap keywords
        if (cpp_highlight.includes(word)) {
            return `<span class="keyword">${word}</span>`;
        }

        let ar;
        if (ar = word.match(/&lt; (.+)/g)) {
            for(w of ar)
            {
                for (let u of w.replace(/,/g, ' ').split(/\s/))
                    if (cpp_highlight.includes(u))
                        word = word.replaceAll(u, `<span class="keyword">${u}</span>`);
            }
            return word;
        }

        // Wrap utility keywords
        if (utils_highlight.includes(word)) {
            return `<span class="utils">${word}</span>`;
        }

        // Replace newline characters with line breaks
        if (word.includes("\n")) {
            return `${word}<br>`;
        }

        return word;
    }).join(' ');

   if (c === "{") {
        return "{ ";
    }

    if (c === "}") {
        return " }";
    }

    if (c === "[") {
        return "[ ";
    }

    if (c === "]") {
        return " ]";
    }

    if (c === "(") {
        return "( ";
    }

    if (c === ")") {
        return " )";
    }
    if (c === ";") {
        return "; ";
    }

    if (c === ",") {
        return ", ";
    }

    if (c === "=") {
        return " = ";
    }

    if (c === "+") {
        return " + ";
    }

    if (c === "-") {
        return " - ";
    }

    if (c === "*") {
        return " * ";
    }

    if (c === "/") {
        return " / ";
    }

    if (c === "%") {
        return " % ";
    }

    if (c === "!") {
        return " ! ";
    }

    if (c === "&") {
        return " & ";
    }

    if (c === "|") {
        return " | ";
    }

    if (c === "^") {
        return " ^ ";
    }

    if (c === "~") {
        return " ~ ";
    }

    if (c === ".") {
        return " . ";
    }

    if (c === "?") {
        return " ? ";
    }

//



    const highlightedCode = code.split(/(\s)/).map((word, index, arr) => {

        // Add space after < or >
        if (word.includes("<")) {
            word = word.replace(/<\s*/g, "&lt; ");
        }

        if (word.includes(">")) {
            word = word.replace(/\s*>/g, " &gt;");
        }

        // Add space before { or }
        if (word.includes("}")) {
            word = word.replace(/\s*}/g, " }");
        }
        
        if (word.includes("{")) {
            word = word.replace(/{\s*/g, "{ ");
        }

        // Add space before [ or ]
        if (word.includes("]")) {
            word = word.replace(/\s*}/g, " ]");
        }
        
        if (word.includes("[")) {
            word = word.replace(/{\s*/g, "[ ");
        }

        // Add space before ( or )
        if (word.includes(")")) {
            word = word.replace(/\s*}/g, " )");
        }
        
        if (word.includes("(")) {
            word = word.replace(/{\s*/g, "( ");
        }

        // handle block comments
        if (block_comment_flag) {
            if (word.includes("*/")) {
                block_comment_flag = false;
                return `${word}</span>`;
            }
            if (word.includes("\n")) {
                return `${word}</span><br>`;
            }
            return word;
        }

        // handle line comments
        if (line_comment_flag) {
            if (word.includes("\n")) {
                line_comment_flag = false;
                return `${word}</span><br>`;
            }
            return word;
        }

        // Check for starting of block comment
        if (word.includes("/*")) {
            block_comment_flag = true;
            return `<span class="comment">${word}`;
        }

        // Check for starting of line comment
        if (word.includes("//") || word.includes("#")) {
            line_comment_flag = true;
            return `<span class="line_comment">${word}`;
        }

        // Wrap numbers
        let nr;
        if (nr = word.match(/(\d+)/g)) {
            for (let n of nr) {
                word = word.replace(n, `<span class="digit">${n}</span>`);
            }
            return word;
        }

        // Wrap scope resolution operators
        if (word.match(/::/)) {
            word = word.replace(/::(\w+)/g, `::<span class="scope">$1</span>`);
        }

        // Wrap keywords
        if (cpp_highlight.includes(word)) {
            return `<span class="keyword">${word}</span>`;
        }

        let ar;
        if (ar = word.match(/&lt; (.+)/g)) {
            for(w of ar)
            {
                for (let u of w.replace(/,/g, ' ').split(/\s/))
                    if (cpp_highlight.includes(u))
                        word = word.replaceAll(u, `<span class="keyword">${u}</span>`);
            }
            return word;
        }

        // Wrap utility keywords
        if (utils_highlight.includes(word)) {
            return `<span class="utils">${word}</span>`;
        }

        // Replace newline characters with line breaks
        if (word.includes("\n")) {
            return `${word}<br>`;
        }

        return word;
    }).join(' ');

    

    /*
    let idx = 0;
    let IDX = codeSnippet.innerHTML.length;
    const JDX = codeSnippet.innerHTML.length;
    let innerHtML = codeSnippet.innerHTML;

    // Find new character position (the first character that is different)
    for(let ch of highlightedCode.split(''))
    {
        if (idx <= IDX)
        {
            if(ch != codeSnippet.lastInnerHtML[idx])
            {
                break
            } else {
                ++idx;
            }
        } else {
            break;
        }
    }
    */
    //codeDisplay.innerHTML = highlightedCode;
    //codeDisplay.scrollTop = codeSnippet.scrollHeight;
	//codeSnippet.innerHTML = codeDisplay.innerHTML;
    //codeDisplay.innerHTML = highlightedCode;//.replace(/\n/gm, "<br>");
    //codeSnippet.innerText = code;
    //codeSnippet.innerHTML = highlightedCode; 
    //IDX = highlightedCode.length;
    // Restore scroll position
    //codeSnippet.scrollTop = savedScrollTop * (codeSnippet.scrollHeight / savedScrollHeight);

    // Restore cursor position
    //setCursorAtPosition(codeSnippet, idx);
    //const restoredRange = document.createRange();
    //restoredRange.setStart(codeSnippet.firstChild, savedCursorPos);
    //restoredRange.setEnd(codeSnippet.firstChild, savedCursorPos);
    //restoredRange.collapse(true);
    //selection.removeAllRanges();
    //selection.addRange(restoredRange);

    //restoredRange.setStart(codeSnippet.lastChild, idx);
    //restoredRange.setEnd(codeSnippet.lastChild, selection.rangeCount);
    //restoredRange.collapse(selection.isCollapsed);
    //selection.removeAllRanges();
    //selection.addRange(restoredRange);
    
    //setCaretPosition(codeSnippet, savedCursorPos);
    
    //const range = document.createRange();
    //const selection = document.getSelection();
    //range.selectNodeContents(codeSnippet);

    // Collapses the Range to the end of the selected node
    //range.collapse(selection.isCollapsed);

    // Remove all ranges from the selection
    //selection.removeAllRanges();

    //range.setStart(codeSnippet.lasttChild, idx);
    //range.setEnd(codeSnippet.lasttChild, selection.rangeCount);

    // Add the Range to the selection
    //selection.addRange(range);

    //if (IDX != JDX)
    //codeSnippet.lastInnerHtML = codeSnippet.innerHTML;

//

    // Save cursor position
    //const selection = document.getSelection();
    //const range = selection.getRangeAt(0);
    //const savedCursorPos = range.startOffset;
    //const savedCursorPos = getCaretCharacterOffsetWithin(codeSnippet);

//

    const currentmode = {
        keyword:{regex:/\w/, mode:0}, // keyword
        digit:{regex:/\d/, mode:1}, // digit
        comment:{regex:/\//, mode:2} // comment
    };

//



    let last = "default";
    let mode = "default";
    let buff = "";

    const currentmode = {
        keyword:{regex:/\w/, mode:"keyword"}, 
        digit:{regex:/\d/, mode:"digit"}, 
        delim:{regex:/\s/, mode:"delim"},
        default:{regex:/\S/, mode:"default"}
    };

    const highlightCode = code.split("").map((c, j, me) => {

        // modes: 1. keyword, 2. digit, 3. comment, 4. line_comment
        let k = j + 1;
        if ((k in me) && !block_comment_flag && !line_comment_flag) {

            if (c === "/" && me[k] === "/") {
                me[k] = "";
                buff = "";
                line_comment_flag = true;
                return `<span class="line_comment">//`;
            }

            if (c === "/" && me[k] === "*") {
                me[k] = "";
                buff = "";
                block_comment_flag = true;
                return `<span class="comment">/*`;
            }

            if (c === ":" && me[k] === ":") {
                scoped = true;
                let u = buff;
                me[k] = "";
                buff = "";
                return u + c + `<span class="scoped">::`;
            }

        } else {

            if (c === "\n") {
                c += "<br>" + line_comment_flag ? "</span>" : "";
                line_comment_flag = false;
            }

            if (c === "<") {
                let u = buff;
                buff = "";
                if (scoped) {
                    u += "</span>";
                    scoped = false;
                }
                u += c;
                return u;
            }

            if (c === ">") {
                return "&gt;";
            }

            if (c.match(currentmode.keyword.regex)){
                if (last === currentmode.keyword.mode) {
                    buff += c;
                    return "";
                } else {

                }
            }
            
            if (c.match(currentmode.digit.regex)) {

            }
            
            if (c.match(currentmode.delim.regex)) {

            }
            
            buff += c;
            return "";
        }

        return c;
    }).join("");

    codeDisplay.innerHTML = highlightCode;
}

//

        // highlight numeric operators
        if (word.match(/[\+\%\^\!\?\~:]+/g))
            return word.replace(/([\+\%\^\!\?\~:]+)/g, `<span class="digit">$1</span>`);
//

        // highlight numeric operators
        if (word.match(/(\+\+)|[%!?]+/g))
            return word.replace(/(\+\+)|[%!?]+/g, `<span class="digit">$1</span>`);

//

    color: skyblue /*darksalmon /*deepskyblue /*darkseagreen /*darkcyan /*darkgoldenrod /*darkorange/* burlywood /*cadetblue * /cornflowerblue*/;
//


        // Check for strings
        if (!inside_quote && word.match(/['"]/)) {
            // Start of a quote
            //quote_char = word.match(/\"/) ? '"' : "'";
            //inside_quote = true;
            return word.match(/\"/) ? 
                word.replace(/\"/,'<span class="string">$1').replace(/\"/,'$1</span>') : 
                word.replace(/\'/,'<span class="string">$1').replace(/\'/,'$1</span>');
        } /*else if (inside_quote && word.includes(quote_char)) {
            // End of a quote
            quote_char = null;
            inside_quote = false;
            return word + '</span>';
        }*/
//

        // Check for strings
        const current_quote = word.match(/['"]/);
        if (current_quote) {
            let single_quote = { first_quote:"'", count:word.match(/\'/g) };
            let double_quote_count = { first_quote:'"', count:word.match(/\"/g) };
            if (inside_quote)
            {
                if (quote_char === single_quote.first_quote) {
                    if (single_quote.count) {
                        inside_quote = false;
                        return word + '</span>';
                    }
                } else {
                    return word;
                }
            }
            inside_quote = true;
            quote_char = 
            if (quote_char === single_quote.first_quote) {
                if (single_quote.count) {
                    return word + '</span>';
                }
            } else {
                return word;
            }
            quote_char = word.match(/\"/) ? '"' : "'";
            return '<span class="string">' + word + '</span>';
        } 
//

        // Check for strings
        const current_quote = word.match(/['"]/);
        if (current_quote) {
            let single_quote = { first_quote:"'", count:word.match(/\'/g) };
            let double_quote = { first_quote:'"', count:word.match(/\"/g) };
            if (inside_quote)
            {
                if (((quote_char === single_quote.first_quote) && single_quote.count) ||
                    ((quote_char === double_quote.first_quote) && double_quote.count)) {
                        inside_quote = false;
                        return word.replace(quote_char,`${word}</span>`);
                } else {
                    return word;
                }
            }
            const we_have_a_completed_scope = ((single_quote.count > 1) || (double_quote.count > 1));
            if (we_have_a_completed_scope) {
                    //inside_quote = false;
                    return `<span class="string">${word}</span>`;
            } else {
                inside_quote = true;
                quote_char = current_quote[0];
                return word.replace(quote_char,`<span class="string">${word}`);
            }
        }
//
function highlightScopeResolutions(code, keywords) {
    // Regular expression to match words with scope resolution operator
    const regex = /(\w+)(::)/g;

    // Function to replace matched strings
    const replacer = (match, p1, p2) => {
        // If the word before :: is a keyword, wrap it in span
        if (keywords.includes(p1)) {
            return `<span class="keyword">${p1}</span>${p2}`;
        }
        return match;
    };

    // Replace matched strings in the code
    return code.replace(regex, replacer);
}

//


<div id="code-snippet" class="code-base transparent-contenteditable" spellcheck="false" placeholder="Enter Comments + C++ Code Snippets here" contenteditable="true" oninput="highlightSyntax()"></div>

//

/* Transparent; Set the caret color to something visible */
.transparent-contenteditable {
    background-color: transparent;
    /*opacity: 0;*/
    color: transparent;
    caret-color: #000;
    position: absolute;
    z-index: 1;
}

//

    //codeSnippet.lastInnerHtML = codeSnippet.innerHTML;

    // Save scroll position
    const savedScrollTop = codeSnippet.scrollTop;
    const savedScrollHeight = codeSnippet.scrollHeight || 1;

    let scoped = false;

//

function resize_code_snippet_editor() {

    const code = codeSnippet.innerText || codeSnippet.textContent || codeSnippet.value;
    codeDisplay.innerHTML = code.split('').map(function(c){
        switch(c) {
            case ' ':
                return '<space></space>';
           // case '\t':
             //   return '<tab></tab>';
            case '\n':
                return '<br>';
            case '<':
                return '&lt;';
            case '>':
                return '&gt;';
            default:
                return c;
        }
    }).join('');

    codeSnippet.style.height = 'auto';
    codeSnippet.style.height = codeDisplay.style.height = codeSnippet.scrollHeight + 'px';
}

//

let http = require('http');
let fs = require('fs');
let path = require('path');
let server = http.createServer((req, res) => {
    var contentType = 'text/html';
    res.writeHead(200, { 'Content-Type': contentType });
    res.end(`<script>console.log(${JSON.stringify(req.url, ' ',2)})</script>`);
    /*
    var filePath = path.join(__dirname, 'public', 'index.html');
    if (req.url.match(/LICENSE/g)) {
        contentType = 'text/plain';
        filePath = path.join(__dirname, 'public', 'LICENSE');
    }
    fs.readFile(filePath, (err, content) => {
        if (err) {
            res.writeHead(500);
            res.end(`Server Error: ${err.code}`);
        } else {
            res.writeHead(200, { 'Content-Type': contentType });
            res.end(content, 'utf-8');
        }
    });
    */
});
server.listen();
